'use strict';

var amqp = require('amqplib/callback_api');

class RabbitMqConnection {
  constructor(connectionString) {
    this.amqpConnection = undefined;
    this.publishingChannels = new Map();

    this.onAmqpConnected = function (conn) { };
    this.connectionString = connectionString;
    this.isConnecting = false;
    this.isReconnectPending = false;
  }

  parseConnectionStringToDisplay(connectionString){
    let temp = connectionString.split('@');
    return temp[temp.length - 1];
  }

  setOnAmqpConnectedCallback(onAmqpConnected) {
    this.onAmqpConnected = onAmqpConnected;
  }

  connect() {
    let connectionStringToDisplay = this.parseConnectionStringToDisplay(this.connectionString);
    console.log('connecting to RabbitMQ at: ' + connectionStringToDisplay);

    if (this.isConnecting == true) return;
    this.isConnecting = true;
    this.isReconnectPending = false;
    amqp.connect(this.connectionString, (err, conn) => {
      this.amqpConnectCallback(err, conn);
    });
  }

  amqpConnectCallback(err, conn) {
    this.amqpConnection = conn;
    this.isConnecting = false;

    if (err) {
      console.error('Could not connect to AMQP', err.message);
      if (this.isConnecting == false) this.onAmqpDisconnected(conn, 10000);
    } else {
      conn.on('error', (err) => {
        console.log('AMQP Lost Connection', err);
        this.onAmqpDisconnected(conn, 5000);
      });

      conn.on("close", () => {
        console.error("connection to RabbitQM closed!");
        this.onAmqpDisconnected(conn, 10000)
      });

      this.onAmqpConnected(conn);
    }
  }

  onAmqpDisconnected(conn, reconnectTimeout) {
    try {
      this.publishingChannels.clear();
      this.amqpConnection = undefined;

      if (conn != undefined) {
        conn.close();
      }
    } catch (error) {
      console.log(error);
      throw error;
    }

    if (this.isReconnectPending == false) {
      this.isReconnectPending = true;
      setTimeout(() => this.connect(), reconnectTimeout);
    }
  }

  subscribeToMessages(amqpConnection, subscriptionInfo, messageReceivedAction) {
    if (amqpConnection == undefined) {
      return;
    }

    try {
      amqpConnection.createChannel((err, ch) => {
        if (err != undefined) {
          console.log(`failed to open connection to ${subscriptionInfo.exchange}`);
          return;
        }

        ch.assertExchange(subscriptionInfo.exchange, subscriptionInfo.exchangeType, {
          durable: subscriptionInfo.durable,
        });

        ch.assertQueue(subscriptionInfo.queue, { exclusive: subscriptionInfo.queueExclusive }, (err, q) => {
          if (err) {
            console.log(err.message);
            return;
          }
          ch.bindQueue(q.queue, subscriptionInfo.exchange, subscriptionInfo.routingKey);
          console.log(`opening connection to ${subscriptionInfo.exchange}`);

          ch.consume(
            q.queue,
            (msg) => {
              var parsedMessage = JSON.parse(msg.content.toString());
              messageReceivedAction(parsedMessage, this);
            },
            { noAck: true }
          );
        });
      });
    } catch (error) {
      console.log('Attempt to subscribe to messages fail:', error.message);
      throw error;
    }
  }

  setupChannelForPublishingMessages(amqpConnection, publishingInfo, channelName) {
    if (amqpConnection == undefined) {
      return;
    }
    try {
      amqpConnection.createChannel((err, channel) => this.createChannel(err, channel, publishingInfo, channelName));
    } catch (error) {
      console.log('Attempt to setup channel for publishing message fail:', error.message);
      throw error;
    }
  }

  createChannel(err, ch, publishingInfo, channelName) {
    ch.assertExchange(publishingInfo.exchange, publishingInfo.exchangeType, { durable: publishingInfo.durable });

    console.log(`opening channel for publishing to ${publishingInfo.exchange}`);
    var channelInfo = {
      channel: ch,
      publishingInfo: publishingInfo,
    };
    this.publishingChannels.set(channelName, channelInfo);
  }

  sendData(channelName, data, routingKey = undefined) {
    try {
      if (this.amqpConnection == undefined || !this.publishingChannels.has(channelName)) {
        return;
      }

      var channelInfo = this.publishingChannels.get(channelName);

      var channel = channelInfo.channel;
      var publishingInfo = channelInfo.publishingInfo;

      if (routingKey == undefined) {
        routingKey = publishingInfo.routingKey;
      }

      var msg = JSON.stringify(data);
      channel.publish(publishingInfo.exchange, routingKey, new Buffer(msg));
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}

module.exports = RabbitMqConnection;
