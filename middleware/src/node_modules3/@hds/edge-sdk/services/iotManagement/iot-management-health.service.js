"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeIoTManagementHealthMonitor = void 0;
const url = __importStar(require("url"));
const rxjs_1 = require("rxjs");
const edge_iot_data_source_model_1 = require("../../models/iotManagement/edge-iot-data-source.model");
const resultStatusObject_1 = require("../../models/api/resultStatusObject");
const __1 = require("../..");
class EdgeIoTManagementHealthMonitor {
    constructor(endpoints, iotManagement, apiCallsService, httpsAgent, serviceProvider) {
        this.primaryChangeTopic = 'Edge/OSH/Events/InsiteBridgeAddress/Current/primary';
        this.oshStatesTopic = 'Edge/OSH/Events/States';
        this.oshModulesTopic = 'Edge/OSH/Events/Module/List';
        this.bridgeAliveInterval = 10000;
        this.bridgeCheckInterval = 5000;
        this.suspendEmitConnectionStatus = false;
        this.endpoints = endpoints;
        this.iotManagement = iotManagement;
        this.apiCallsService = apiCallsService;
        this.httpsAgent = httpsAgent;
        this.serviceProvider = serviceProvider;
        this.initializeDataStatus();
    }
    get isMqttConnected$() {
        return this.mqttClient ? this.mqttClient.isConnected$ : rxjs_1.of(false);
    }
    startTracking() {
        if (this.mqttClient != null) {
            return;
        }
        this.initializeMQTTClient();
        this.initializeStateTracking();
    }
    initializeMQTTClient() {
        this.mqttClient = this.serviceProvider.mqtt;
        this.setupMqttOptions();
        this.mqttClient.subscribe(this.primaryChangeTopic);
        this.mqttClient.subscribe(this.oshStatesTopic);
        this.mqttClient.subscribe(this.oshModulesTopic);
    }
    async initializeStateTracking() {
        this.iotManagement.connectivityState.on(this.iotManagement.stateEventName, () => this.updateStatusChanged());
        try {
            await this.setPrimaryBridgeInfo();
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, 'Initialization attempt to set Bridge info failed.');
        }
    }
    initializeDataStatus() {
        this.statusObject = new edge_iot_data_source_model_1.EdgeIoTDataSourceStatus();
        this.statusObject.status = false;
        this.statusObject.message = 'initializing';
        this._iotHealthStatus = new rxjs_1.BehaviorSubject(this.statusObject);
        this.iotHealthStatus = this._iotHealthStatus.asObservable();
    }
    setupMqttOptions() {
        this.mqttClient.isConnected$.subscribe(_ => {
            this.updateStatusChanged();
        });
        this.mqttClient.message$.subscribe(({ topic, message }) => {
            switch (topic) {
                case this.bridgeHealthTopic:
                    this.onBridgeStatus(message);
                    break;
                case this.primaryChangeTopic:
                    this.setPrimaryBridgeInfo(message);
                    break;
                case this.oshStatesTopic:
                    const modules = JSON.parse(message.toString());
                    this.iotManagement.updateStates(modules);
                    break;
                case this.oshModulesTopic:
                    const info = JSON.parse(message.toString());
                    if (info.currentModuleList) {
                        this.iotManagement.checkModulesList(info.currentModuleList);
                    }
                    break;
                default:
                    break;
            }
        });
    }
    subscribeToBridgeStatus(inSiteInfo) {
        this.primaryBridgeInfo = inSiteInfo;
        this.bridgeHealthTopic = this.getAliveTopic();
        this.lastAliveTimestamp = Date.now();
        this.mqttClient.subscribe(this.bridgeHealthTopic);
        if (this.healthCheckInterval != null) {
            clearInterval(this.healthCheckInterval);
        }
        this.healthCheckInterval = setInterval(() => this.checkIfBridgeAlive(), this.bridgeCheckInterval);
    }
    updateStatusChanged() {
        if (!this.mqttClient.isConnected) {
            if (this.statusObject.isMqttConnected !== this.mqttClient.isConnected) {
                this.setNoConnectionStatus('No MQTT connection');
            }
            return;
        }
        if (!this.isBridgeRunning) {
            if (this.statusObject.message !== 'InSite Bridge is not connected') {
                this.setNoConnectionStatus('InSite Bridge is not connected');
            }
            return;
        }
        if (!this.isInsiteConnected) {
            if (this.statusObject.message !== 'Insite Not Connected') {
                this.setNoConnectionStatus('Insite Not Connected');
            }
            return;
        }
        if (this.mapWithIoTStatus()) {
            this.emitConnectionStatus();
        }
    }
    mapWithIoTStatus() {
        let state = this.iotManagement.getConnectivityState();
        if (!state) {
            state = { connected: true, moduleNames: undefined };
        }
        // if still connected to all and MQTT do not send message
        if (this.statusObject.status && this.statusObject.status === state.connected) {
            return false;
        }
        this.statusObject.message = 'Connected';
        if (!state.connected) {
            if (state.moduleNames == null) {
                this.statusObject.message = 'No IoT modules connected';
            }
            else {
                this.statusObject.message = 'IoT connection issues';
            }
            this.statusObject.invalidIotModules = state.moduleNames;
        }
        this.statusObject.status = state.connected;
        this.statusObject.isMqttConnected = this.mqttClient.isConnected;
        return true;
    }
    async onBridgeResetConnection() {
        if (!this.isBridgeRunning) {
            return;
        }
        this.isBridgeRunning = false;
        this.isInsiteConnected = false;
        this.updateStatusChanged();
    }
    setNoConnectionStatus(message) {
        this.statusObject.invalidIotModules = undefined;
        this.statusObject.message = message;
        this.statusObject.status = false;
        this.statusObject.isMqttConnected = this.mqttClient.isConnected;
        this.emitConnectionStatus();
    }
    emitConnectionStatus() {
        if (this.suspendEmitConnectionStatus) {
            return;
        }
        this._iotHealthStatus.next(this.statusObject);
    }
    getAliveTopic() {
        return `Insite_${this.primaryBridgeInfo.bridgeUUID}/connection/status/liveUpdates`;
    }
    checkIfBridgeAlive() {
        if (this.lastAliveTimestamp < Date.now() - this.bridgeAliveInterval) {
            this.isBridgeRunning = false;
            this.updateStatusChanged();
        }
    }
    onBridgeStatus(message) {
        try {
            const status = JSON.parse(message.toString());
            let statusChanged = false;
            this.lastAliveTimestamp = Date.now();
            if (this.isInsiteConnected !== status.isInsiteConnected) {
                this.isInsiteConnected = status.isInsiteConnected;
                statusChanged = true;
            }
            if (!this.isBridgeRunning) {
                this.isBridgeRunning = true;
                statusChanged = true;
            }
            if (statusChanged) {
                this.updateStatusChanged();
            }
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `SDK error trying to process Bridge status message... ${error.message}`);
        }
    }
    async setPrimaryBridgeInfo(message = null) {
        try {
            if (message != null) {
                __1.LogService.log(__1.LOG_LEVEL.SYSTEM_INFO, message.toString());
            }
            await this.onBridgeResetConnection();
            const info = await this.getBridgeId();
            this.primaryBridgeInfo = info;
            this.subscribeToBridgeStatus(info);
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `Primary Bridge set attempt: ${error.message}`);
            setTimeout(() => {
                this.setPrimaryBridgeInfo();
            }, 10000);
        }
    }
    async getBridgeId() {
        const uri = url.resolve(this.endpoints.edgeApiAddress, this.endpoints.edgeBridgeApiBase);
        try {
            const response = await this.apiCallsService.get(`${uri}/current`);
            if (response.status === resultStatusObject_1.ResultStatus.OK) {
                return response.result;
            }
            else {
                throw Error(response.message);
            }
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `Error occurred on attempt to retrieve primary Bridge Id ${error.message}`);
        }
    }
}
exports.EdgeIoTManagementHealthMonitor = EdgeIoTManagementHealthMonitor;
