"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeIoTManagement = void 0;
const events_1 = require("events");
const url = __importStar(require("url"));
const __1 = require("../..");
const resultStatusObject_1 = require("../../models/api/resultStatusObject");
const iot_management_model_1 = require("../../models/iotManagement/iot-management.model");
const ums_meta_model_1 = require("../../models/iotManagement/ums-meta.model");
const async_utils_1 = require("../../utils/async-utils");
const api_call_service_1 = require("../api-call.service");
const edgeIoTPersistence_1 = require("./edgeIoTPersistence");
const iot_config_service_1 = require("./iot-config.service");
const iot_generic_factory_1 = require("./iot-generic.factory");
const iot_management_health_service_1 = require("./iot-management-health.service");
class EdgeIoTManagement {
    constructor(endpoints, serviceProvider, httpsAgent) {
        this.connectivityState = new events_1.EventEmitter();
        this.stateEventName = 'newState';
        this.sensors = [];
        this.publishers = [];
        this.initialized = false;
        this.overlap = (a, b, p) => a.filter((aa) => b.find((bb) => aa[p] === bb[p]));
        try {
            this.endpoints = endpoints;
            this.serviceProvider = serviceProvider;
            this.httpsAgent = httpsAgent;
            this.configProvider = new iot_config_service_1.IotConfigProvider(this.endpoints.iotManagement);
            this.apiCallsService = new api_call_service_1.ApiCallsService(this.httpsAgent);
            this.healthMonitor = new iot_management_health_service_1.EdgeIoTManagementHealthMonitor(this.endpoints, this, this.apiCallsService, this.httpsAgent, this.serviceProvider);
        }
        catch (error) {
            throw error;
        }
    }
    getIoTHealthStatus() {
        this.healthMonitor.startTracking();
        return this.healthMonitor.iotHealthStatus;
    }
    getSensors() {
        return this.sensors.map((s) => {
            const info = new iot_management_model_1.EdgeIotModule();
            info.id = s.id;
            info.name = s.name;
            info.state = s.state;
            return info;
        });
    }
    getPublishers() {
        return this.publishers.map((p) => {
            const info = new iot_management_model_1.EdgeIotModule();
            info.id = p.id;
            info.name = p.name;
            info.state = p.state;
            return info;
        });
    }
    async start() {
        this.initialize();
        try {
            this.sensors = [];
            this.publishers = [];
            await this.loadSensors();
            await this.loadPublishers();
            const command = 'start';
            const state = iot_management_model_1.IOT_MODULE_STATE.STARTED;
            await this.setStateToItems(`${this.publishersBase}/state`, command, state, this.publishers);
            await this.setStateToItems(`${this.sensorsBase}/state`, command, state, this.sensors);
            await this.updateModuleStates();
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `IoT management SDK on start: ${error.message}`);
        }
    }
    async stop() {
        try {
            const state = iot_management_model_1.IOT_MODULE_STATE.STOPPED;
            const command = 'stop';
            await this.setStateToAll(command, state);
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `On stop IoT items: ${error.message}`);
        }
    }
    async reset() {
        throw new Error('Method not implemented.');
    }
    async delete() {
        try {
            const promises = [];
            for (const item of this.sensors) {
                const params = { id: item.id };
                const uri = url.resolve(this.endpoints.iotManagement.baseIoTAddress, this.sensorsBase);
                promises.push(this.apiCallsService.delete(uri, params));
            }
            for (const item of this.publishers) {
                const params = { id: item.id };
                const uri = url.resolve(this.endpoints.iotManagement.baseIoTAddress, this.publishersBase);
                promises.push(this.apiCallsService.delete(uri, params));
            }
            await Promise.all(promises);
            this.sensors = [];
            this.publishers = [];
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `IoT management SDK delete IoT module: ${error.message}`);
        }
    }
    updateStates(updateItems) {
        if (!this.initialized) {
            return;
        }
        try {
            let updatedOne = false;
            const modulesCollection = this.getFullCollection();
            for (const item of updateItems) {
                const result = this.findAndUpdate(modulesCollection, item);
                if (result) {
                    updatedOne = true;
                }
            }
            if (updatedOne) {
                this.updateConnectivityState();
            }
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `IoT management SDK update states attempt: ${error}`);
        }
    }
    checkModulesList(modulesList) {
        if (!this.initialized) {
            return;
        }
        try {
            let updatedOne = false;
            const obj = {};
            modulesList.forEach((el, i) => {
                obj[el.id] = el.state;
            });
            const modulesCollection = this.getFullCollection();
            modulesCollection.forEach((el) => {
                let state = iot_management_model_1.IOT_MODULE_STATE.STOPPED;
                if (obj[el.id] !== undefined) {
                    state = obj[el.id];
                }
                const updated = this.updateState(el, state);
                updatedOne = updated ? true : updatedOne;
            });
            if (updatedOne) {
                this.updateConnectivityState();
            }
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `'IoT management SDK modules check: ${error}`);
        }
    }
    updateErrors(updateItems) {
        if (!this.initialized) {
            return;
        }
        try {
            let updatedOne = false;
            const modulesCollection = this.getFullCollection();
            for (const item of updateItems) {
                const result = this.findAndUpdateError(modulesCollection, item);
                if (result) {
                    updatedOne = true;
                }
            }
            if (updatedOne) {
                this.updateConnectivityState();
            }
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `IoT management SDK errors update: ${error.message}`);
        }
    }
    getConnectivityState() {
        return this._cachedState;
    }
    async getPublishersMeta() {
        let umsMeta = [];
        await async_utils_1.AsyncUtils.forEach(this.publishers, async (publisher) => {
            const result = await this.getServiceMetaFromOsh(publisher.id);
            const filterResult = result.filter((x) => x.unitClassEnumName !== ums_meta_model_1.CLASS_none && x.unitMeasureEnumName !== ums_meta_model_1.MEASURE_unitless);
            if (filterResult.length > 0) {
                umsMeta = umsMeta.concat(result);
            }
        });
        return umsMeta;
    }
    getServiceMetaFromOsh(id) {
        const uri = `${this.configProvider.iotConfig.baseIoTAddress}${this.configProvider.iotConfig.api_uri}${this.configProvider.iotConfig.ums_meta}`;
        const params = { id };
        return this.apiCallsService.get(uri, params);
    }
    initialize() {
        if (this.initialized) {
            return;
        }
        try {
            this.edgePersistence = new edgeIoTPersistence_1.EdgeIoTPersistenceService(this.serviceProvider.dbConnection);
            // tslint:disable-next-line: max-line-length
            this.sensorsBase = `${this.configProvider.iotConfig.api_uri}${this.configProvider.iotConfig.sensors_uri}`;
            this.publishersBase = `${this.configProvider.iotConfig.api_uri}${this.configProvider.iotConfig.services_uri}`;
            this.factory = new iot_generic_factory_1.IotManagementGenericFactory(this.apiCallsService, this.configProvider);
            this.initialized = true;
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `Edge SDK fail: ${error.message}`);
            throw error;
        }
    }
    async loadSensors() {
        await this.checkFixedSensors();
        __1.LogService.log(__1.LOG_LEVEL.SYSTEM_INFO, `Sensors: ${JSON.stringify(this.sensors.map((s) => s.name))}`);
    }
    async updateModuleStates() {
        const apiSensors = await this.apiCallsService.get(url.resolve(this.endpoints.iotManagement.baseIoTAddress, this.sensorsBase));
        const apiPublishers = await this.apiCallsService.get(url.resolve(this.endpoints.iotManagement.baseIoTAddress, this.publishersBase));
        const allItems = apiSensors.concat(apiPublishers);
        this.updateStates(allItems);
    }
    async checkFixedSensors() {
        const response = await this.edgePersistence.getSensors();
        const apiSensors = await this.apiCallsService.get(url.resolve(this.endpoints.iotManagement.baseIoTAddress, this.sensorsBase));
        const fixedSensorConfigs = this.getSensorConfigs();
        const databaseSaved = response.result;
        const fixedApi = this.overlap(apiSensors, databaseSaved, 'id');
        if (fixedApi && fixedApi.length === fixedSensorConfigs.length) {
            for (const fixedOverlap of fixedApi) {
                this.mapSensorOfResponse(fixedOverlap);
            }
        }
        else {
            await this.cleanUpSensors(databaseSaved, fixedApi);
            await this.createSensors();
        }
    }
    async cleanUpSensors(databaseSaved, apiCreated) {
        await this.edgePersistence.removeSensors(databaseSaved);
        async_utils_1.AsyncUtils.forEach(apiCreated, async (elem) => {
            const params = { id: elem.id };
            try {
                await this.apiCallsService.delete(url.resolve(this.endpoints.iotManagement.baseIoTAddress, this.sensorsBase), params);
            }
            catch (error) {
                __1.LogService.log(__1.LOG_LEVEL.ERROR, 'Errors occurred on sensors clean up');
            }
        });
    }
    async cleanUpPublishers(databaseSaved, apiCreated) {
        await this.edgePersistence.removeServices(databaseSaved);
        async_utils_1.AsyncUtils.forEach(apiCreated, async (elem) => {
            const params = { id: elem.id };
            try {
                await this.apiCallsService.delete(url.resolve(this.endpoints.iotManagement.baseIoTAddress, this.publishersBase), params);
            }
            catch (error) {
                __1.LogService.log(__1.LOG_LEVEL.ERROR, 'Errors occurred on publishers clean up');
            }
        });
    }
    mapSensorOfResponse(sensorInfo) {
        const newSensor = new iot_management_model_1.EdgeIotModule();
        newSensor.name = sensorInfo.name;
        newSensor.id = sensorInfo.id;
        newSensor.state = sensorInfo.state;
        this.sensors.push(newSensor);
    }
    mapPublisherOfResponse(publisherInfo) {
        const newPublisher = new iot_management_model_1.EdgeIotModule();
        newPublisher.name = publisherInfo.name;
        newPublisher.id = publisherInfo.id;
        newPublisher.state = publisherInfo.state;
        this.publishers.push(newPublisher);
    }
    async loadPublishers() {
        const configPublishers = this.getPublisherConfigs();
        const savedDBResponse = await this.edgePersistence.getServices();
        const apiPublishers = await this.apiCallsService.get(url.resolve(this.endpoints.iotManagement.baseIoTAddress, this.publishersBase));
        const publishersExisting = this.overlap(apiPublishers, savedDBResponse.result, 'id');
        if (publishersExisting && publishersExisting.length === configPublishers.length) {
            for (const publisher of publishersExisting) {
                this.mapPublisherOfResponse(publisher);
            }
        }
        else {
            await this.cleanUpPublishers(savedDBResponse.result, publishersExisting);
            await this.createPublishers();
        }
        __1.LogService.log(__1.LOG_LEVEL.SYSTEM_INFO, `Publishers: ${JSON.stringify(this.publishers.map((p) => p.name))}`);
    }
    async setStateToAll(command, state) {
        await Promise.all([
            this.setStateToItems(`${this.sensorsBase}/state`, command, state, this.sensors),
            this.setStateToItems(`${this.publishersBase}/state`, command, state, this.publishers),
        ]);
    }
    getFullCollection() {
        const result = [];
        return result.concat(this.sensors).concat(this.publishers);
    }
    updateConnectivityState() {
        const modules = this.getFullCollection();
        const issues = modules.filter((m) => m.state !== iot_management_model_1.IOT_MODULE_STATE.STARTED || m.hasErrors);
        const started = modules.find((m) => m.state === iot_management_model_1.IOT_MODULE_STATE.STARTED);
        const state = new iot_management_model_1.IotConnectionState();
        state.connected = true;
        if (issues && issues.length > 0) {
            state.connected = false;
            if (started) {
                state.moduleNames = issues.map((i) => i.name);
            }
        }
        this._cachedState = state;
        this.connectivityState.emit(this.stateEventName, state);
    }
    findAndUpdate(collection, updateItem) {
        const item = collection.find((i) => i.id === updateItem.id);
        if (item) {
            this.updateState(item, updateItem.state);
            return true;
        }
        return false;
    }
    updateState(item, state) {
        if (item.state === state) {
            return false;
        }
        item.state = state;
        item.hasErrors = false;
        return true;
    }
    findAndUpdateError(collection, updateItem) {
        const item = collection.find((i) => i.id === updateItem.moduleId);
        if (item && !item.hasErrors) {
            item.hasErrors = true;
            return true;
        }
        return false;
    }
    setStateToItems(uri, command, state, collection) {
        const promises = [];
        for (const item of collection) {
            item.state = state;
            const params = { id: item.id, state: command };
            uri = url.resolve(this.endpoints.iotManagement.baseIoTAddress, uri);
            promises.push(this.apiCallsService.put(uri, null, params));
        }
        return Promise.all(promises);
    }
    async createSensors() {
        const sensorConfigs = this.getSensorConfigs();
        try {
            const response = await this.factory.createSensors(sensorConfigs);
            if (response.status === resultStatusObject_1.ResultStatus.OK) {
                this.sensors = this.sensors.concat(response.result);
                const dbSensors = this.sensors.map((s) => {
                    return { id: s.id };
                });
                await this.edgePersistence.addSensors(dbSensors);
            }
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, error.message);
        }
    }
    async createPublishers() {
        const configs = this.getPublisherConfigs();
        try {
            const response = await this.factory.createPublishers(configs);
            if (response.status === resultStatusObject_1.ResultStatus.OK) {
                this.publishers = this.publishers.concat(response.result);
                const dbServices = this.publishers.map((p) => {
                    return { id: p.id };
                });
                await this.edgePersistence.addServices(dbServices);
            }
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, error.message);
        }
    }
    getSensorConfigs() {
        return this.configProvider.getSensorConfigs();
    }
    getPublisherConfigs() {
        return this.configProvider.getSPublisherConfigs();
    }
}
exports.EdgeIoTManagement = EdgeIoTManagement;
