"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeInSiteHealthMonitor = void 0;
const rxjs_1 = require("rxjs");
const __1 = require("..");
const historian_1 = require("../historian");
class EdgeInSiteHealthMonitor {
    constructor(mqttClient, insiteRtClient) {
        this.primaryChangeTopic = 'Edge/OSH/Events/InsiteBridgeAddress/Current/primary';
        this.oshStatesTopic = 'Edge/OSH/Events/States';
        this.oshModulesTopic = 'Edge/OSH/Events/Module/List';
        this.bridgeAliveInterval = 10000;
        this.bridgeCheckInterval = 5000;
        this.suspendEmitConnectionStatus = false;
        try {
            this.mqttClient = mqttClient;
            this.insiteRtClient = insiteRtClient;
            this.statusObject = new historian_1.EdgeHistorianDataSubscriptionsStatus();
            this.statusObject.status = false;
            this.statusObject.message = 'initializing';
            this._subscriptionsHealthStatus = new rxjs_1.BehaviorSubject(this.statusObject);
            this.subscriptionsHealthStatus = this._subscriptionsHealthStatus.asObservable();
            if (this.mqttClient) {
                this.mqttClient.subscribe(this.primaryChangeTopic);
            }
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `InSite health monitor constructor error ${error.message}`);
        }
    }
    onBridgeStatus(status) {
        const wasConnected = this.isBridgeRunning && this.isInsiteConnected;
        let statusChanged = false;
        this.lastAliveTimestamp = Date.now();
        if (this.isInsiteConnected !== status.isInsiteConnected) {
            this.isInsiteConnected = status.isInsiteConnected;
            statusChanged = true;
        }
        if (!this.isBridgeRunning) {
            this.isBridgeRunning = true;
            statusChanged = true;
        }
        const isConnected = this.isBridgeRunning && this.isInsiteConnected;
        if (isConnected && isConnected !== wasConnected) {
            this.restore();
        }
        else if (statusChanged) {
            this.updateStatusChanged();
        }
    }
    subscribeToBridgeStatus(inSiteInfo) {
        this.inSiteInfo = inSiteInfo;
        this.topic = this.getAliveTopic();
        this.lastAliveTimestamp = Date.now();
        this.mqttClient.subscribe(this.topic);
        if (this.healthCheckInterval != null) {
            clearInterval(this.healthCheckInterval);
        }
        this.healthCheckInterval = setInterval(() => this.checkIfBridgeAlive(), this.bridgeCheckInterval);
    }
    updateStatusChanged() {
        if (!this.mqttClient.isConnected) {
            if (this.statusObject.isMqttConnected !== this.mqttClient.isConnected) {
                this.setNoConnectionStatus('No MQTT connection');
            }
            return;
        }
        if (!this.isBridgeRunning) {
            if (this.statusObject.message !== 'InSite Bridge is not connected') {
                this.setNoConnectionStatus('InSite Bridge is not connected');
            }
            return;
        }
        if (!this.isInsiteConnected) {
            if (this.statusObject.message !== 'Insite Not Connected') {
                this.setNoConnectionStatus('Insite Not Connected');
            }
            return;
        }
        this.statusObject.message = 'Connected';
        const subsStatus = { hasInvalidVariables: false, connected: true };
        const invalidSubscriptions = this.insiteRtClient.getSubscriptionsUpdateStatus(subsStatus);
        this.statusObject.subscriptionsInfo = invalidSubscriptions;
        if (!subsStatus.connected && subsStatus.hasInvalidVariables) {
            this.statusObject.message = 'Connection issues occur';
        }
        // if still connected to all and MQTT do not send message
        if (this.statusObject.status && this.statusObject.status === subsStatus.connected) {
            return;
        }
        this.statusObject.status = subsStatus.connected;
        this.statusObject.isMqttConnected = this.mqttClient.isConnected;
        this.emitConnectionStatus();
    }
    async onBridgeResetConnection() {
        if (this.isBridgeRunning) {
            this.isBridgeRunning = false;
            this.isInsiteConnected = false;
            this.updateStatusChanged();
        }
        this.suspendEmitConnectionStatus = true;
        await this.insiteRtClient.stopSubscriptions();
        this.suspendEmitConnectionStatus = false;
    }
    setNoConnectionStatus(message) {
        this.statusObject.subscriptionsInfo = undefined;
        this.statusObject.message = message;
        this.statusObject.status = false;
        this.statusObject.isMqttConnected = this.mqttClient.isConnected;
        this.emitConnectionStatus();
    }
    emitConnectionStatus() {
        if (this.suspendEmitConnectionStatus) {
            return;
        }
        this._subscriptionsHealthStatus.next(this.statusObject);
    }
    getAliveTopic() {
        return `Insite_${this.inSiteInfo.bridgeUUID}/connection/status/liveUpdates`;
    }
    checkIfBridgeAlive() {
        if (this.lastAliveTimestamp < Date.now() - this.bridgeAliveInterval) {
            this.isBridgeRunning = false;
            this.updateStatusChanged();
        }
    }
    restore() {
        try {
            this.suspendEmitConnectionStatus = true;
            this.insiteRtClient
                .restoreSubscriptions()
                .then(() => {
                this.suspendEmitConnectionStatus = false;
                this.updateStatusChanged();
                this.emitConnectionStatus();
            })
                .catch((error) => {
                __1.LogService.log(__1.LOG_LEVEL.ERROR, `Attempt to restore subscriptions fail: ${error.message}`);
                this.suspendEmitConnectionStatus = true;
            });
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `error on restore ${error}`);
            this.suspendEmitConnectionStatus = false;
        }
    }
}
exports.EdgeInSiteHealthMonitor = EdgeInSiteHealthMonitor;
