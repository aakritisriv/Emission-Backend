"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeInsiteRtClient = void 0;
const axios_1 = __importDefault(require("axios"));
const rxjs_1 = require("rxjs");
const url = __importStar(require("url"));
const uuid_1 = require("uuid");
const __1 = require("..");
const edgeHistorianData_1 = require("../models/api/historian/edgeHistorianData");
const resultStatusObject_1 = require("../models/api/resultStatusObject");
const edgeSubscriptionStatus_1 = require("../models/edgeSubscriptionStatus");
const edgeHistorianSubscriptionInfoManager_1 = require("../models/historian/edgeHistorianSubscriptionInfoManager");
const resultStatusObject_2 = require("./../models/api/resultStatusObject");
const edgeInSiteHealthMonitor_1 = require("./edgeInSiteHealthMonitor");
class EdgeInsiteRtClient {
    constructor(serviceProvider, edgeApiAddress, httpsAgent, disableStreaming) {
        this.clientId = `sdk_${uuid_1.v4()}`;
        this.heartbeatInterval = 20000;
        this.subscriptionAliveInterval = 10000;
        this.edgeInsiteApiBase = '/api/v1/data';
        this.edgeBridgeApiBase = '/api/v1/services/insite';
        this.realTimeSubscriptionExtension = '/realtime/subscriptions';
        this.realTimePublisherExtension = '/realtime/publishers';
        this.topicCallbackMap = {};
        this.requestedSubscriptions = {};
        this.requestedPublishers = {};
        // init MQTT Bridge API urls
        this.edgeApiAddress = edgeApiAddress;
        this.httpsAgent = httpsAgent;
        if (!disableStreaming) {
            this.mqttClient = serviceProvider.mqtt;
            setImmediate(() => this.setupMqttOptions());
        }
        this.initializeSubscriptionsHealthStatus();
    }
    get isMqttConnected$() {
        return this.mqttClient ? this.mqttClient.isConnected$ : rxjs_1.of(false);
    }
    createDataSubscription(dataInfo, callback) {
        const subId = uuid_1.v4().toString();
        const requestedSubscription = new edgeHistorianSubscriptionInfoManager_1.EdgeHistorianSubscriptionInfoManager(dataInfo, callback);
        this.requestedSubscriptions[subId] = requestedSubscription;
        this.startSubscription(requestedSubscription);
        return subId;
    }
    async removeDataSubscription(subscriptionId) {
        const subscription = this.requestedSubscriptions[subscriptionId];
        if (subscription === undefined) {
            return;
        }
        if (subscription.subscriptionInfo && subscription.subscriptionInfo.subscriptionId) {
            try {
                const response = await axios_1.default.delete(`/${subscription.subscriptionInfo.subscriptionId}`, {
                    timeout: 20000,
                    baseURL: this.getClientSubscriptionsBaseUrl(),
                    httpsAgent: this.httpsAgent,
                    proxy: false,
                });
                if (response && response.data && response.data) {
                    if (response.data.status != 0) {
                        __1.LogService.log(__1.LOG_LEVEL.SYSTEM_INFO, response.data.message);
                    }
                    else {
                        __1.LogService.log(__1.LOG_LEVEL.SYSTEM_INFO, `Edge SDK removed subscription: ${response.data.result}`);
                    }
                }
            }
            catch (error) {
                __1.LogService.log(__1.LOG_LEVEL.ERROR, error);
            }
        }
        this.stopSubscription(subscription);
        delete this.requestedSubscriptions[subscriptionId];
    }
    createDataPublisher(dataInfo) {
        const subId = uuid_1.v4().toString();
        const requestedPublisher = new edgeHistorianSubscriptionInfoManager_1.EdgeHistorianPublisherInfoManager(dataInfo);
        this.requestedPublishers[subId] = requestedPublisher;
        this.startPublisher(requestedPublisher);
        return subId;
    }
    removeDataPublisher(publisherId) {
        const publisher = this.requestedPublishers[publisherId];
        if (!publisher) {
            return;
        }
        this.stopPublisher(publisher);
        delete this.requestedPublishers[publisherId];
    }
    publishDataToPublisher(publisherId, data) {
        var _a;
        try {
            const publisher = this.requestedPublishers[publisherId];
            if (!data ||
                !publisher ||
                publisher.status !== edgeSubscriptionStatus_1.EdgeSubscriptionStatus.CONNECTED ||
                !publisher.publisherInfo ||
                !((_a = this.mqttClient) === null || _a === void 0 ? void 0 : _a.isConnected)) {
                return;
            }
            this.mqttClient.publish(publisher.publisherInfo.mqttTopic, JSON.stringify(data));
        }
        catch (err) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `Historian Publisher failed to send message to publisher id: ${publisherId}`);
        }
    }
    async getRecordLastRow(recordQuery) {
        return new Promise((resolve, reject) => {
            axios_1.default
                .post('/getRecordLastRow', recordQuery, {
                timeout: 10000,
                baseURL: this.getDataBaseUrl(),
                httpsAgent: this.httpsAgent,
                proxy: false,
            })
                .then((response) => {
                resolve(Object.assign(new edgeHistorianData_1.EdgeHistorianData(), response.data.result));
            }, (error) => {
                this.logError('getRecordLastRow', error);
                resolve(undefined);
            });
        });
    }
    async getRecordRows(recordQuery) {
        return new Promise((resolve, reject) => {
            axios_1.default
                .post('/getRecordRows', recordQuery, {
                timeout: 30000,
                baseURL: this.getDataBaseUrl(),
                httpsAgent: this.httpsAgent,
                proxy: false,
            })
                .then((response) => {
                resolve(Object.assign(new edgeHistorianData_1.EdgeHistorianData(), response.data.result));
            }, (error) => {
                this.logError('getRecordRows', error);
                resolve(undefined);
            });
        });
    }
    async getRecordRowsByTime(recordQuery) {
        return new Promise((resolve, reject) => {
            axios_1.default
                .post('/getRecordRowsByTime', recordQuery, {
                timeout: 30000,
                baseURL: this.getDataBaseUrl(),
                httpsAgent: this.httpsAgent,
                proxy: false,
            })
                .then((response) => {
                resolve(Object.assign(new edgeHistorianData_1.EdgeHistorianData(), response.data.result));
            }, (error) => {
                this.logError('getRecordRowsByTime', error);
                resolve(undefined);
            });
        });
    }
    async getRecordRowsByDepth(recordQuery) {
        return new Promise((resolve, reject) => {
            axios_1.default
                .post('/getRecordRowsByDepth', recordQuery, {
                timeout: 30000,
                baseURL: this.getDataBaseUrl(),
                httpsAgent: this.httpsAgent,
                proxy: false,
            })
                .then((response) => {
                resolve(Object.assign(new edgeHistorianData_1.EdgeHistorianData(), response.data.result));
            }, (error) => {
                this.logError('getRecordRowsByDepth', error);
                resolve(undefined);
            });
        });
    }
    async writeRecordRows(recordQuery) {
        return new Promise((resolve, reject) => {
            axios_1.default
                .post('/writeRecordRows', recordQuery, {
                timeout: 30000,
                baseURL: this.getDataBaseUrl(),
                httpsAgent: this.httpsAgent,
                proxy: false,
            })
                .then((response) => {
                resolve(Object.assign(new edgeHistorianData_1.EdgeHistorianData(), response.data.result));
            }, (error) => {
                this.logError('writeRecordRows', error);
                resolve(undefined);
            });
        });
    }
    restoreSubscriptions() {
        const promises = [];
        for (const key in this.requestedSubscriptions) {
            if (this.requestedSubscriptions.hasOwnProperty(key)) {
                const subscription = this.requestedSubscriptions[key];
                subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.NOT_CONNECTED;
                promises.push(this.startSubscription(subscription));
            }
        }
        return Promise.all(promises);
    }
    stopSubscriptions() {
        const promises = [];
        for (const key in this.requestedSubscriptions) {
            if (this.requestedSubscriptions.hasOwnProperty(key)) {
                const subscription = this.requestedSubscriptions[key];
                promises.push(this.stopSubscription(subscription));
            }
        }
        return Promise.all(promises);
    }
    getSubscriptionsUpdateStatus(status) {
        let invalidSubscriptions = [];
        for (const key in this.requestedSubscriptions) {
            if (this.requestedSubscriptions.hasOwnProperty(key)) {
                const subscription = this.requestedSubscriptions[key];
                const subInfo = subscription.subscriptionInfo;
                const hasInvalidVariables = subInfo == null || this.hasInvalidVariables(subInfo);
                if (hasInvalidVariables) {
                    status.hasInvalidVariables = true;
                }
                if (subscription.status !== edgeSubscriptionStatus_1.EdgeSubscriptionStatus.CONNECTED || hasInvalidVariables) {
                    status.connected = false;
                    if (subInfo != null && hasInvalidVariables) {
                        invalidSubscriptions = invalidSubscriptions.concat(subInfo.subscribedRecords);
                    }
                    else {
                        // if record invalid or any other reason causing to fail subscription mark all as invalid
                        const info = subscription.dataInfo;
                        const newInfo = {
                            record: info.record,
                            descriptor: info.descriptor,
                            variables: info.variables,
                            isWellBased: info.isWellBased,
                            invalidVariables: info.variables,
                        };
                        invalidSubscriptions.push(newInfo);
                    }
                }
            }
        }
        return invalidSubscriptions;
    }
    getBridgeId() {
        const baseReqUrl = url.resolve(this.edgeApiAddress, this.edgeBridgeApiBase);
        return new Promise((resolve, reject) => {
            axios_1.default
                .get('/current', {
                timeout: 30000,
                baseURL: baseReqUrl,
                httpsAgent: this.httpsAgent,
                proxy: false,
            })
                .then((response) => {
                if (response.data.status === resultStatusObject_2.ResultStatus.OK) {
                    resolve(response.data.result);
                }
                else {
                    reject(response.data.message);
                }
                // resolve(Object.assign(new EdgeHistorianData(), response.data.result));
            }, (error) => {
                this.logError('get Bridge Id', error);
                reject(error.message);
            });
        });
    }
    hasInvalidVariables(subscriptionInfo) {
        let hasInvalid = false;
        subscriptionInfo.subscribedRecords.forEach((record) => {
            if (record.invalidVariables != null && record.invalidVariables.length > 0) {
                return (hasInvalid = true);
            }
        });
        return hasInvalid;
    }
    initializeSubscriptionsHealthStatus() {
        this.connectionMonitor = new edgeInSiteHealthMonitor_1.EdgeInSiteHealthMonitor(this.mqttClient, this);
        this.subscriptionsHealthStatus = this.connectionMonitor.subscriptionsHealthStatus;
        this.setPrimaryBridgeInfo();
    }
    logError(queryName, error) {
        let message = `unspecified error`;
        const response = error.response;
        if (response && response.data) {
            const status = response.data.status;
            const internalError = status === resultStatusObject_1.ResultStatusLegacy.ERROR || status === resultStatusObject_2.ResultStatus.ERROR;
            message = internalError ? response.data.message : error;
        }
        __1.LogService.log(__1.LOG_LEVEL.ERROR, `${queryName} data query failed: ${message}.`);
    }
    async stopSubscription(subscription) {
        if (!subscription || subscription.status === edgeSubscriptionStatus_1.EdgeSubscriptionStatus.DISPOSED) {
            return;
        }
        try {
            subscription.clearTimers();
            subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.DISPOSED;
            this.connectionMonitor.updateStatusChanged();
            if (subscription.subscriptionInfo) {
                this.mqttClient.unsubscribe([
                    subscription.subscriptionInfo.mqttTopic,
                    subscription.subscriptionInfo.mqttSubscriptionAliveTopic,
                ]);
                delete this.topicCallbackMap[subscription.subscriptionInfo.mqttTopic];
                delete this.topicCallbackMap[subscription.subscriptionInfo.mqttSubscriptionAliveTopic];
                subscription.subscriptionInfo = undefined;
            }
        }
        catch (err) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `Historian - error while stopping subscription: ${err}`);
        }
    }
    getDataBaseUrl() {
        return url.resolve(this.edgeApiAddress, this.edgeInsiteApiBase);
    }
    getClientSubscriptionsBaseUrl() {
        return url.resolve(this.edgeApiAddress, `${this.edgeInsiteApiBase}${this.realTimeSubscriptionExtension}/${this.clientId}`);
    }
    getClientPublisherBaseUrl() {
        return url.resolve(this.edgeApiAddress, `${this.edgeInsiteApiBase}${this.realTimePublisherExtension}/${this.clientId}`);
    }
    async startSubscription(subscription) {
        if (this.connectionMonitor &&
            (!this.connectionMonitor.isBridgeRunning || !this.connectionMonitor.isInsiteConnected)) {
            return;
        }
        if (subscription &&
            subscription.status !== edgeSubscriptionStatus_1.EdgeSubscriptionStatus.DISPOSED &&
            (subscription.status === edgeSubscriptionStatus_1.EdgeSubscriptionStatus.NOT_CONNECTED ||
                subscription.status === edgeSubscriptionStatus_1.EdgeSubscriptionStatus.FAILED)) {
            try {
                if (subscription.subscriptionInfo) {
                    this.stopSubscription(subscription);
                }
                subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.CONNECTING;
                const subscriptionRequest = {
                    subscriptions: [subscription.dataInfo],
                };
                const subscriptionResponse = await axios_1.default.post('/register', subscriptionRequest, {
                    timeout: 20000,
                    baseURL: this.getClientSubscriptionsBaseUrl(),
                    httpsAgent: this.httpsAgent,
                    proxy: false,
                });
                if (!subscriptionResponse || !subscriptionResponse.data) {
                    throw Error('no/invalid response from server');
                }
                if (subscriptionResponse.status !== 200) {
                    __1.LogService.log(__1.LOG_LEVEL.WARNING, `Historian data subscription invalid response code: ${subscriptionResponse.status}`);
                    // don't return, just note issue
                }
                if (subscriptionResponse.data.status > 0) {
                    throw Error(subscriptionResponse.data.message);
                }
                if (!subscriptionResponse.data.result) {
                    throw Error('no subscription info received from service');
                    return;
                }
                const subscriptionInfo = subscriptionResponse.data.result;
                subscription.subscriptionInfo = subscriptionInfo;
                subscriptionInfo.subscribedRecords.forEach((record) => {
                    __1.LogService.log(__1.LOG_LEVEL.SYSTEM_INFO, `Edge SDK subscribed ${subscriptionInfo.mqttTopic}: ${JSON.stringify(record)}`);
                });
                subscription.healthcheck.heartbeatTimerId = setInterval(() => this.sendHeartbeatForClient(subscriptionInfo.mqttClientHeartbeatTopic, subscription.healthcheck), this.heartbeatInterval);
                this.topicCallbackMap[subscriptionInfo.mqttTopic] = subscription.callback;
                this.topicCallbackMap[subscriptionInfo.mqttSubscriptionAliveTopic] = () => {
                    subscription.healthcheck.lastAliveTimestamp = Date.now();
                };
                this.mqttClient.subscribe([subscriptionInfo.mqttTopic, subscriptionInfo.mqttSubscriptionAliveTopic]);
                // only wire up when everything else has succeeded
                subscription.healthcheck.subscriptionCheckTimerId = setInterval(() => this.checkIfSubscriptionIsAlive(subscription), this.subscriptionAliveInterval);
                subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.CONNECTED;
                this.connectionMonitor.updateStatusChanged();
            }
            catch (err) {
                // wait 15 and try again
                subscription.clearTimers();
                subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.FAILED;
                setTimeout(() => this.startSubscription(subscription), 15000);
                const errorMessage = err.response != null && err.response.data != null && err.response.data.message != null
                    ? err.response.data.message
                    : err.message;
                __1.LogService.log(__1.LOG_LEVEL.ERROR, `Historian data subscription failed: ${errorMessage}`);
                this.connectionMonitor.updateStatusChanged();
            }
        }
    }
    async stopPublisher(publisher) {
        if (!publisher) {
            return;
        }
        try {
            publisher.clearTimers();
            if (publisher.publisherInfo) {
                this.mqttClient.unsubscribe(publisher.publisherInfo.mqttSubscriptionAliveTopic);
                delete this.topicCallbackMap[publisher.publisherInfo.mqttSubscriptionAliveTopic];
                publisher.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.NOT_CONNECTED;
                publisher.publisherInfo = undefined;
            }
        }
        catch (err) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `Historian - error while stopping publisher: ${err}`);
        }
    }
    async startPublisher(publisher) {
        if (publisher &&
            publisher.status !== edgeSubscriptionStatus_1.EdgeSubscriptionStatus.DISPOSED &&
            (publisher.status === edgeSubscriptionStatus_1.EdgeSubscriptionStatus.NOT_CONNECTED || publisher.status === edgeSubscriptionStatus_1.EdgeSubscriptionStatus.FAILED)) {
            try {
                if (publisher.publisherInfo) {
                    this.stopPublisher(publisher);
                }
                publisher.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.CONNECTING;
                const publisherRequest = {
                    recordToWriteTo: publisher.dataInfo,
                };
                const publisherResponse = await axios_1.default.post('/register', publisherRequest, {
                    timeout: 20000,
                    baseURL: this.getClientPublisherBaseUrl(),
                    httpsAgent: this.httpsAgent,
                    proxy: false,
                });
                if (!publisherResponse || !publisherResponse.data) {
                    throw Error('no/invalid response from server');
                }
                if (publisherResponse.status !== 200) {
                    __1.LogService.log(__1.LOG_LEVEL.WARNING, `Historian data publisher invalid response code: ${publisherResponse.status}`);
                    // don't return, just note issue
                }
                if (publisherResponse.data.status > 0) {
                    throw Error(publisherResponse.data.message);
                }
                if (!publisherResponse.data.result) {
                    throw Error('no publisher info received from service');
                }
                const publisherInfo = publisherResponse.data.result;
                publisher.publisherInfo = publisherInfo;
                publisher.healthcheck.heartbeatTimerId = setInterval(() => this.sendHeartbeatForClient(publisherInfo.mqttClientHeartbeatTopic, publisher.healthcheck), this.heartbeatInterval);
                this.topicCallbackMap[publisherInfo.mqttSubscriptionAliveTopic] = () => {
                    publisher.healthcheck.lastAliveTimestamp = Date.now();
                };
                this.mqttClient.subscribe([publisherInfo.mqttTopic, publisherInfo.mqttSubscriptionAliveTopic]);
                // only wire up when everything else has succeeded
                publisher.healthcheck.subscriptionCheckTimerId = setInterval(() => this.checkIfPublisherIsAlive(publisher), this.subscriptionAliveInterval);
                publisher.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.CONNECTED;
            }
            catch (err) {
                // wait 5 and try again
                publisher.clearTimers();
                publisher.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.FAILED;
                setTimeout(() => this.startPublisher(publisher), 15000);
                __1.LogService.log(__1.LOG_LEVEL.ERROR, `Historian data publisher failed: ${err}`);
            }
        }
    }
    checkIfSubscriptionIsAlive(subscription) {
        if (subscription.healthcheck.lastAliveTimestamp < Date.now() - this.subscriptionAliveInterval) {
            subscription.healthcheck.clearTimers();
            subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.FAILED;
            setImmediate(() => this.startSubscription(subscription));
        }
    }
    checkIfPublisherIsAlive(publisher) {
        if (publisher.healthcheck.lastAliveTimestamp < Date.now() - this.subscriptionAliveInterval) {
            publisher.healthcheck.clearTimers();
            publisher.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.FAILED;
            setImmediate(() => this.startPublisher(publisher));
        }
    }
    sendHeartbeatForClient(clientHeartbeatTopic, healtCheckInfo) {
        var _a;
        if ((_a = this.mqttClient) === null || _a === void 0 ? void 0 : _a.isConnected) {
            this.mqttClient.publish(clientHeartbeatTopic, JSON.stringify({ count: healtCheckInfo.counter++ }));
        }
    }
    setupMqttOptions() {
        this.mqttClient.isConnected$.subscribe(_ => {
            this.connectionMonitor.updateStatusChanged();
        });
        this.mqttClient.message$.subscribe(({ topic, message }) => {
            const callback = this.topicCallbackMap[topic];
            if (this.connectionMonitor) {
                if (this.connectionMonitor.topic === topic) {
                    this.onBridgeStatus(message);
                    return;
                }
                if (this.connectionMonitor.primaryChangeTopic === topic) {
                    this.setPrimaryBridgeInfo(message);
                    return;
                }
            }
            if (callback && message) {
                let data;
                try {
                    data = Object.assign(new edgeHistorianData_1.EdgeHistorianData(), JSON.parse(message.toString()));
                }
                catch (err) {
                    __1.LogService.log(__1.LOG_LEVEL.ERROR, 'Historian received non IEdgeHistorianData message...');
                    return;
                }
                callback(data);
            }
        });
    }
    onBridgeStatus(message) {
        try {
            this.connectionMonitor.onBridgeStatus(JSON.parse(message.toString()));
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `SDK error trying to process Bridge status message... ${error.message}`);
        }
    }
    async setPrimaryBridgeInfo(message = null) {
        try {
            if (message != null) {
                __1.LogService.log(__1.LOG_LEVEL.SYSTEM_INFO, message.toString());
            }
            await this.connectionMonitor.onBridgeResetConnection();
            const info = await this.getBridgeId();
            this.primaryBridgeInfo = info;
            this.connectionMonitor.subscribeToBridgeStatus(info);
        }
        catch (error) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `Primary Bridge set attempt: ${error.message}`);
        }
    }
}
exports.EdgeInsiteRtClient = EdgeInsiteRtClient;
