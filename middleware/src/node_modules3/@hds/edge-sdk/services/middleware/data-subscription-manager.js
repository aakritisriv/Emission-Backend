"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataSubscriptionManager = void 0;
const rxjs_1 = require("rxjs");
const subscriptions_db_1 = require("../../db/subscriptions.db");
const data_subscription_model_1 = require("../../models/middleware/data-subscription.model");
const deep_copy_utils_1 = require("../../utils/deep-copy-utils");
/**
 * Enables data grouping for specific user(UI) needs
 * so API and WebSocket supports data retrieving and updates for
 * specific variables scope not sending all cached data
 */
class DataSubscriptionManager {
    constructor(dbConnection, webSocket) {
        var _a;
        this._initialized = new rxjs_1.Subject();
        this._subscriptionAdded = new rxjs_1.Subject();
        this._subscriptionRemoved = new rxjs_1.Subject();
        this.subscriptions = {};
        this.initialized$ = this._initialized.asObservable();
        this.subscriptionAdded$ = this._subscriptionAdded.asObservable();
        this.subscriptionRemoved$ = this._subscriptionRemoved.asObservable();
        this.webSocket = webSocket;
        if (dbConnection != null) {
            this.db = new subscriptions_db_1.SubscriptionsDB(dbConnection);
        }
        (_a = this.db) === null || _a === void 0 ? void 0 : _a.getCachedSubscriptions().then(async (cachedSubscriptions) => {
            cachedSubscriptions.forEach((subscription) => {
                var _a;
                this.subscriptions[subscription.uniqueName] = subscription;
                (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.addNamespace(subscription.uniqueName);
            });
            this._initialized.next(this.getSubscriptions());
            this._initialized.complete();
        });
    }
    /**
     * Add new subscription for data grouping
     * @param dataSubscription info required to add subscription
     */
    addSubscription(dataSubscription) {
        var _a, _b;
        // remove duplicates
        dataSubscription.variables = [...new Set(dataSubscription.variables)];
        this.subscriptions[dataSubscription.uniqueName] = dataSubscription;
        (_a = this.db) === null || _a === void 0 ? void 0 : _a.cacheSubscription(dataSubscription);
        this._subscriptionAdded.next(dataSubscription);
        (_b = this.webSocket) === null || _b === void 0 ? void 0 : _b.addNamespace(dataSubscription.uniqueName);
    }
    /**
     * Remove subscription
     * @param uniqueName string identifier of subscription provided when added
     */
    removeSubscription(uniqueName) {
        var _a;
        const subscription = this.subscriptions[uniqueName];
        delete this.subscriptions[uniqueName];
        (_a = this.db) === null || _a === void 0 ? void 0 : _a.removeSubscription(uniqueName);
        this._subscriptionRemoved.next(subscription);
        // will not remove io namespace for now as there may be subscribed listeners (to discuss)
    }
    /**
     * Retrieve all registered subscriptions info
     */
    getSubscriptions() {
        const subscriptions = [];
        for (const key in this.subscriptions) {
            if (this.subscriptions.hasOwnProperty(key)) {
                const storedSubscription = this.subscriptions[key];
                const subscription = new data_subscription_model_1.DataSubscription();
                subscription.uniqueName = storedSubscription.uniqueName;
                subscription.variables = storedSubscription.variables;
                subscriptions.push(subscription);
            }
        }
        return subscriptions;
    }
    /**
     * Retrieve specific subscription info
     * @param uniqueName string identifier of subscription provided when added
     */
    getSubscriptionInfo(uniqueName) {
        if (this.subscriptions.hasOwnProperty(uniqueName)) {
            return deep_copy_utils_1.DeepCopyUtil.deepCopy(this.subscriptions[uniqueName]);
        }
    }
}
exports.DataSubscriptionManager = DataSubscriptionManager;
