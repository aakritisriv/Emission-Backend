"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeServiceMQTTClient = void 0;
const uuid_1 = require("uuid");
const edgeSubscriptionStatus_1 = require("../models/edgeSubscriptionStatus");
const edgeServiceSubscriptionInfoManager_1 = require("../models/serviceToService/edgeServiceSubscriptionInfoManager");
const edgeData_1 = require("../models/edgeData");
const serviceToService_1 = require("../serviceToService");
const __1 = require("..");
const edgeS2STopicBase = 'HAL/EDGE/S2S/';
// const edgeS2SSubscriberHeartbeatPostfix = "client"
// const edgeS2SPublisherHeartbeatPostfix = "publisher"
class EdgeServiceMQTTClient {
    constructor(serviceProvider, httpsAgent) {
        // public onMessage: EventEmitter = new EventEmitter();
        this.clientId = `sdk_${uuid_1.v4()}`;
        this.topicCallbackInfoMap = {};
        this.requestedSubscriptions = {};
        this.httpsAgent = httpsAgent;
        this.mqttClient = serviceProvider.mqtt;
        this.setupMqttOptions();
    }
    generateEdgeServiceGroupTopic(group, topic) {
        return `${edgeS2STopicBase}${group}/${topic}`;
    }
    createSubscriptionToServiceGroup(group, topic, messageType, callback) {
        var subId = uuid_1.v4().toString();
        //todo: validate group & topic dont contain chars that violate mqtt topic rules
        var fullMqttTopic = this.generateEdgeServiceGroupTopic(group, topic);
        var requestedSubscription = new edgeServiceSubscriptionInfoManager_1.EdgeServiceCommunicationInfoManager(group, topic, fullMqttTopic, messageType, callback);
        this.requestedSubscriptions[subId] = requestedSubscription;
        this.startSubscription(requestedSubscription);
        return subId;
    }
    isASCII(str) {
        return /^[\x41-\x7A]*$/.test(str);
    }
    async removeServiceGroupSubscription(subscriptionId) {
        var subscription = this.requestedSubscriptions[subscriptionId];
        if (subscription == undefined) {
            return;
        }
        this.stopSubscription(subscription);
        delete this.requestedSubscriptions[subscriptionId];
    }
    async stopSubscription(subscription) {
        if (subscription == undefined) {
            return;
        }
        try {
            if (subscription.subscribedMqttTopic != undefined) {
                // var mqttPublisherConfig = subscription.serviceInfo.publisherConfig as MQTTPublisherConfig;
                // var keepAliveTopic = subscription.serviceInfo.serviceCheckConfig.serviceAliveConfig.topic;
                this.mqttClient.unsubscribe(subscription.subscribedMqttTopic);
                delete this.topicCallbackInfoMap[subscription.subscribedMqttTopic];
                subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.NOT_CONNECTED;
            }
        }
        catch (err) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `S2S - error while stopping subscription: ${err}`);
        }
    }
    async startSubscription(subscription) {
        if (subscription != undefined &&
            subscription.status != edgeSubscriptionStatus_1.EdgeSubscriptionStatus.CONNECTED &&
            subscription.status != edgeSubscriptionStatus_1.EdgeSubscriptionStatus.CONNECTING) {
            if (this.topicCallbackInfoMap[subscription.subscribedMqttTopic] != undefined) {
                throw Error('Group/Topic Combo already registered.  Cannot register twice from the same service');
            }
            try {
                this.topicCallbackInfoMap[subscription.subscribedMqttTopic] = subscription;
                this.mqttClient.subscribe(subscription.subscribedMqttTopic);
                subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.CONNECTED;
            }
            catch (err) {
                subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.FAILED;
                setTimeout(() => this.startSubscription(subscription), 5000);
                __1.LogService.log(__1.LOG_LEVEL.ERROR, `S2S data subscription failed: ${err}`);
            }
        }
    }
    publishDataToPublisher(group, topic, publishMode, data) {
        try {
            if (this.mqttClient.isConnected == false) {
                return false;
            }
            var message = undefined;
            switch (publishMode) {
                case serviceToService_1.EdgeServicePublishMessageMode.STRING_OR_BUFFER:
                    message = data;
                    break;
                case serviceToService_1.EdgeServicePublishMessageMode.CONVERT_TO_JSON:
                    message = JSON.stringify(data);
            }
            var publishTopic = this.generateEdgeServiceGroupTopic(group, topic);
            this.mqttClient.publish(publishTopic, message);
            return true;
        }
        catch (err) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `S2S Publisher failed to send message: ${err}`);
            return false;
        }
    }
    setupMqttOptions() {
        this.mqttClient.message$.subscribe(({ topic, message }) => {
            if (message == undefined) {
                return;
            }
            var subscription = this.topicCallbackInfoMap[topic];
            if (subscription == undefined) {
                return;
            }
            var callback = subscription.callback;
            if (callback == undefined) {
                return;
            }
            var data = undefined;
            try {
                switch (subscription.messageType) {
                    case serviceToService_1.EdgeServiceMessageType.EDGE_DATA_OBJECT:
                        data = Object.assign(new edgeData_1.EdgeData(), JSON.parse(message.toString()));
                        break;
                    case serviceToService_1.EdgeServiceMessageType.JSON_OBJECT:
                        data = JSON.parse(message.toString());
                        break;
                    case serviceToService_1.EdgeServiceMessageType.STRING:
                        data = message.toString();
                        break;
                    case serviceToService_1.EdgeServiceMessageType.UNHANDLED:
                    default:
                        data = message;
                }
            }
            catch (err) {
                __1.LogService.log(__1.LOG_LEVEL.ERROR, 'S2S received non valid message...');
                return;
            }
            callback(data);
        });
    }
}
exports.EdgeServiceMQTTClient = EdgeServiceMQTTClient;
