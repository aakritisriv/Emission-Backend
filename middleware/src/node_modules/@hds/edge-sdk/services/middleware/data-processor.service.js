"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataProcessor = void 0;
const deep_copy_utils_1 = require("./../../utils/deep-copy-utils");
const rxjs_1 = require("rxjs");
const __1 = require("../..");
const data_cache_db_1 = require("../../db/data-cache.db");
const cache_data_model_1 = require("../../models/middleware/cache-data.model");
const data_message_model_1 = require("../../models/middleware/data-message.model");
const data_model_1 = require("../../models/middleware/data.model");
const logger_model_1 = require("./../../models/common/logger.model");
const logger_service_1 = require("./../common/logger.service");
const rmq_data_service_1 = require("./rmq-data.service");
class DataProcessor {
    constructor(dataSubscription, dbConnection, webSocket, rmq, rabbitMqConfig) {
        this._cacheLoaded = new rxjs_1.Subject();
        this.edgeDataProcessors = [];
        this.dataModelsProcessors = [];
        this.dataResultProcessors = [];
        this.dataCache = new Map();
        this.cacheLoaded$ = this._cacheLoaded.asObservable();
        this.dataSubscription = dataSubscription;
        this.webSocket = webSocket;
        if (rmq != null) {
            this.rmqDataService = new rmq_data_service_1.RmqDataService(this, rmq, rabbitMqConfig);
        }
        if (dbConnection != null) {
            this.db = new data_cache_db_1.DataCacheDB(dbConnection);
            this.db
                .getCacheEdgeData()
                .then((cacheDB) => {
                if (cacheDB != null) {
                    this.setDataCache(cacheDB);
                }
                this._cacheLoaded.next(true);
                this._cacheLoaded.complete();
            })
                .catch((err) => {
                logger_service_1.LogService.log(logger_model_1.LOG_LEVEL.ERROR, `On DB cache load attempt: ${err.message}`);
            });
        }
        else {
            this._cacheLoaded.next(true);
            this._cacheLoaded.complete();
        }
    }
    /**
     * Publishes data to RMQ in Edge format
     * if configured using publish configuration part
     * @param data data message in IDataMessage format
     */
    publishDataToRMQ(data, routingKey) {
        const edgeData = this.convertToEdgeData(data);
        this.publishEdgeDataToRMQ(edgeData, routingKey);
        return edgeData;
    }
    /**
     * Publishes data to RMQ in Edge format
     * if configured using publish configuration part
     * @param data data message in EdgeData format
     */
    publishEdgeDataToRMQ(data, routingKey) {
        if (this.rmqDataService == null) {
            throw Error('RMQ data publishing is disabled');
        }
        this.rmqDataService.sendDataToDefault(data, routingKey);
        return data;
    }
    /**
     * Adds callback to chain of data processors executed sequentially for each incoming Edge data message
     * @param func callback function added to process Edge data message
     */
    useEdgeDataProcessor(func) {
        this.edgeDataProcessors.push(func);
    }
    /**
     * Adds callback to chain of data processors executed sequentially for each incoming Data models message
     * @param func callback function added to process Data model data message
     */
    useDataModelsProcessor(func) {
        this.dataModelsProcessors.push(func);
    }
    /**
     * Adds callback to handle data result after data n=message was processed by processors and cached
     * @param func data processed result handler callback
     */
    onDataProcessedResult(func) {
        this.dataResultProcessors.push(func);
    }
    /**
     * Set data to process by registered Edge data processors
     * afterwards data will be cached and published to WS if configured
     * @param message EdgeData format message
     */
    processMessage(message) {
        const edgeData = Object.assign(new __1.EdgeData(), message);
        for (const rawProcessor of this.edgeDataProcessors) {
            rawProcessor(edgeData);
        }
        const dataModels = this.edgeDataToDataModels(edgeData);
        this.cacheAndProcessResults(dataModels);
    }
    /**
     * Set data to process by registered Data model processors
     * afterwards data will be cached and published to WS if configured
     * @param dataModels data in format of Map<string, IDataModel>
     */
    processDataModels(dataModels) {
        for (const dataModelsProcessor of this.dataModelsProcessors) {
            dataModelsProcessor(dataModels);
        }
        this.cacheAndProcessResults(dataModels);
    }
    /**
     * Converts data message to IEdgeData format
     * @param data data message
     */
    convertToEdgeData(data) {
        let edgeData;
        for (const variableName in data) {
            if (Object.prototype.hasOwnProperty.call(data, variableName)) {
                const dataModel = data[variableName];
                if (Object.prototype.hasOwnProperty.call(dataModel, 'value')) {
                    const value = dataModel['value'];
                    if (!edgeData) {
                        edgeData = new __1.EdgeData();
                        edgeData.info.timestamp = Date.now();
                        edgeData.data[0] = [];
                    }
                    const pos = edgeData.getVariablePosition(variableName);
                    if (pos) {
                        // edgeData.data[0][pos] = value;
                        throw Error(`Data has duplicated variable name: ${variableName}`);
                    }
                    else {
                        edgeData.variables.push(variableName);
                        edgeData.data[0].push(value);
                    }
                }
            }
        }
        return edgeData;
    }
    /**
     * Retrieve cache data for specific subscription in format of IDataMessage
     * @param uniqueKey subscription unique name used when subscription registered
     */
    getSubscriptionData(uniqueKey) {
        const subscription = this.dataSubscription.getSubscriptionInfo(uniqueKey);
        if (!subscription) {
            throw Error(`Subscription ${uniqueKey} doesn't exist.`);
        }
        return this.createDataMessage(this.dataCache, subscription.variables);
    }
    /**
     * Get variable data model from cache
     */
    getCachedVariable(variableName) {
        if (!this.dataCache.has(variableName)) {
            return;
        }
        return this.dataCache.get(variableName);
    }
    /**
     * check if there's data model in cache for specific variable
     */
    hasVariableCache(variableName) {
        return this.dataCache.has(variableName);
    }
    /**
     * Retrieve whole data cache
     */
    getCacheData() {
        const cacheDataObject = new cache_data_model_1.CacheData();
        this.dataCache.forEach((value, key) => {
            cacheDataObject.variables.push(key);
            cacheDataObject.data.push(value);
        });
        return cacheDataObject;
    }
    /**
     * Get whole cache in format of IDataMessage
     */
    getCacheDataMessage() {
        return this.createDataMessage(this.dataCache);
    }
    cacheAndProcessResults(dataModels) {
        const resultDataModels = this.cacheDataModels(dataModels);
        for (const dataResultProcessor of this.dataResultProcessors) {
            dataResultProcessor(resultDataModels);
        }
        // send result data models to subscribers over WS
        this.processRealTimeForSubscribers(resultDataModels);
    }
    setDataCache(cache) {
        const resultMap = new Map();
        if (cache.variables) {
            for (let index = 0; index < cache.variables.length; index++) {
                const variableName = cache.variables[index];
                const variableValue = cache.data[index];
                if (typeof variableValue === 'object') {
                    resultMap.set(variableName, variableValue);
                }
            }
        }
        // if any message was received
        if (this.dataCache.size > 0) {
            this.dataCache.forEach((value, key) => {
                resultMap.set(key, value);
            });
        }
        this.dataCache = resultMap;
    }
    processRealTimeForSubscribers(deltaDataModels, uniqueName) {
        if (!this.webSocket) {
            return;
        }
        if (deltaDataModels.size < 1) {
            return;
        }
        const subscriptions = this.dataSubscription.getSubscriptions();
        const index = subscriptions.findIndex((x) => x.uniqueName === uniqueName);
        if (uniqueName && index != -1) {
            this.processSocketMessage(deltaDataModels, subscriptions[index]);
        }
        else {
            subscriptions.forEach((info) => {
                this.processSocketMessage(deltaDataModels, info);
            });
        }
    }
    processSocketMessage(deltaDataModels, info) {
        if (this.webSocket == null) {
            return;
        }
        const dataMessage = this.createDataMessage(deltaDataModels, info.variables);
        // send message over WebSocket
        if (dataMessage) {
            this.webSocket.broadcastToNamespace(info.uniqueName, DataProcessor.messageName, dataMessage);
        }
    }
    createDataMessage(modelsMap, variablesToFilter = null) {
        const dataMessage = new data_message_model_1.DataMessage();
        let notEmpty = false;
        // filter by variable names list - else include all variables in message
        if (variablesToFilter) {
            variablesToFilter.forEach((variableName) => {
                if (modelsMap.has(variableName)) {
                    const model = modelsMap.get(variableName);
                    dataMessage[variableName] = this.mapDataModelToMessageModel(model);
                    notEmpty = true;
                }
            });
        }
        else {
            // include all cached variables in message
            if (this.dataCache.size > 0) {
                notEmpty = true;
            }
            this.dataCache.forEach((value, key) => {
                dataMessage[key] = this.mapDataModelToMessageModel(value);
            });
        }
        // return undefined in case of empty message
        return notEmpty ? dataMessage : undefined;
    }
    mapDataModelToMessageModel(dataModel) {
        const messageModel = new data_message_model_1.DataMessageModel();
        messageModel.value = dataModel.value;
        messageModel.timestamp = dataModel.timestamp;
        return messageModel;
    }
    edgeDataToDataModels(data) {
        const dataModels = new Map();
        data.variables.forEach((variableName) => {
            const value = data.getVariableInRow(0, variableName);
            const dataModel = this.createDataModel(value);
            dataModels.set(variableName, dataModel);
        });
        return dataModels;
    }
    cacheDataModels(models) {
        var _a;
        const dataModels = new Map();
        models.forEach((model, variableName) => {
            this.dataCache.set(variableName, model);
            const resultCopy = deep_copy_utils_1.DeepCopyUtil.deepCopy(model);
            dataModels.set(variableName, resultCopy);
        });
        if (dataModels.size > 0) {
            (_a = this.db) === null || _a === void 0 ? void 0 : _a.cacheEdgeData(this.getCacheData());
        }
        return dataModels;
    }
    createDataModel(value) {
        const resultDataModel = new data_model_1.DataModel();
        resultDataModel.value = value;
        resultDataModel.timestamp = Date.now();
        return resultDataModel;
    }
}
exports.DataProcessor = DataProcessor;
/**
 * WebSocket message name used to publish processing results
 */
DataProcessor.messageName = 'realTimeData';
