"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeSDK = exports.EdgeSDKConfig = void 0;
const fs = __importStar(require("fs"));
const https = __importStar(require("https"));
const __1 = require("..");
const edgeHistorianDataQuery_1 = require("../models/api/historian/edgeHistorianDataQuery");
const TelemetryRequestBuilder = __importStar(require("../models/telemetry/edgeTelemetryRequestBuilders"));
const config_provider_1 = require("./common/config.provider");
const logger_service_1 = require("./common/logger.service");
const router_provider_1 = require("./common/router.provider");
const service_provider_1 = require("./common/service.provider");
/**
 * @module EdgeSDK
 */
const edgeInsiteRtClient_1 = require("./edgeInsiteRtClient");
const edgeServiceMQTTClient_1 = require("./edgeServiceMQTTClient");
const edgeTelemetryMQTTClient_1 = require("./edgeTelemetryMQTTClient");
const edgeIoTManagement_1 = require("./iotManagement/edgeIoTManagement");
const common_middleware_service_1 = require("./middleware/common-middleware.service");
class EdgeServiceCommunicationSDK {
    constructor(serviceProvider, httpsAgent, disableStreaming) {
        this._disableStreaming = disableStreaming;
        if (this._disableStreaming != true)
            this._serviceMQTTClient = new edgeServiceMQTTClient_1.EdgeServiceMQTTClient(serviceProvider, httpsAgent);
    }
    subscribeToServiceGroupData(group, topic, messageType, callback) {
        if (this._disableStreaming == true) {
            throw Error('Streaming is disabled');
        }
        return this._serviceMQTTClient.createSubscriptionToServiceGroup(group, topic, messageType, callback);
    }
    unsubscribeFromServiceGroupData(subscriptionId) {
        if (this._disableStreaming == true) {
            throw Error('Streaming is disabled');
        }
        return this._serviceMQTTClient.removeServiceGroupSubscription(subscriptionId);
    }
    publishServiceGroupData(group, topic, publishMode, data) {
        if (this._disableStreaming == true) {
            throw Error('Streaming is disabled');
        }
        return this._serviceMQTTClient.publishDataToPublisher(group, topic, publishMode, data);
    }
}
// tslint:disable-next-line: max-classes-per-file
class EdgeHistorianSDK {
    constructor(serviceProvider, edgeApiAddress, httpsAgent, disableStreaming) {
        this._insiteMqttClient = new edgeInsiteRtClient_1.EdgeInsiteRtClient(serviceProvider, edgeApiAddress, httpsAgent, disableStreaming);
        this.subscriptionsHealthStatus = this._insiteMqttClient.subscriptionsHealthStatus;
    }
    get isMqttConnected$() {
        return this._insiteMqttClient.isMqttConnected$;
    }
    subscribeToDataChange(subscriptionInfo, callback) {
        if (this._disableStreaming == true) {
            throw Error('Streaming is disabled');
        }
        return this._insiteMqttClient.createDataSubscription(subscriptionInfo, callback);
    }
    unsubscribeFromHistorianDataChange(subscriptionId) {
        if (this._disableStreaming == true) {
            throw Error('Streaming is disabled');
        }
        this._insiteMqttClient.removeDataSubscription(subscriptionId);
    }
    async registerHistorianDataPublisher(publisherInfo) {
        if (this._disableStreaming == true) {
            throw Error('Streaming is disabled');
        }
        return await this._insiteMqttClient.createDataPublisher(publisherInfo);
    }
    unregisterHistorianDataPublisher(publisherId) {
        if (this._disableStreaming == true) {
            throw Error('Streaming is disabled');
        }
        this._insiteMqttClient.removeDataPublisher(publisherId);
    }
    async publishDataToHistorian(publisherId, data) {
        if (this._disableStreaming == true) {
            throw Error('Streaming is disabled');
        }
        return await this._insiteMqttClient.publishDataToPublisher(publisherId, data);
    }
    async queryHistorianData(query) {
        if (query == undefined) {
            return undefined;
        }
        switch (query.type) {
            case edgeHistorianDataQuery_1.EdgeHistorianDataQueryType.LAST_ROW:
                return await this._insiteMqttClient.getRecordLastRow(query);
            case edgeHistorianDataQuery_1.EdgeHistorianDataQueryType.MULTI_ROW:
                return await this._insiteMqttClient.getRecordRows(query);
            case edgeHistorianDataQuery_1.EdgeHistorianDataQueryType.TIME_BASED:
                return await this._insiteMqttClient.getRecordRowsByTime(query);
            case edgeHistorianDataQuery_1.EdgeHistorianDataQueryType.DEPTH_BASED:
                return await this._insiteMqttClient.getRecordRowsByDepth(query);
            default:
                logger_service_1.LogService.log(__1.LOG_LEVEL.ERROR, `Unhandled Historian Query Type: ${query.type}`);
                return undefined;
        }
    }
    async writeRecordRows(query) {
        return await this._insiteMqttClient.writeRecordRows(query);
    }
}
// tslint:disable-next-line: max-classes-per-file
class EdgeTelemetrySDK {
    constructor(serviceProvider, edgeApiAddress, httpsAgent, disableStreaming) {
        this._disableStreaming = disableStreaming;
        if (this._disableStreaming != true) {
            this._edgeTelemetryMqttClient = new edgeTelemetryMQTTClient_1.EdgeTelemetryMQTTClient(serviceProvider, edgeApiAddress, httpsAgent);
        }
    }
    registerTelemetryService(edgeTelemetryRequest) {
        return this._edgeTelemetryMqttClient.registerTelemetryService(edgeTelemetryRequest);
    }
    createCustomTelemetryServiceSubscription(apiRequest, callback) {
        if (this._disableStreaming == true) {
            throw Error('Streaming is disabled');
        }
        return this._edgeTelemetryMqttClient.createCustomDataSubscription(apiRequest, callback);
    }
    createInboundTelemetryServiceSubscription(sdkRequest, callback) {
        if (this._disableStreaming == true) {
            throw Error('Streaming is disabled');
        }
        const apiRequest = TelemetryRequestBuilder.convertEdgeTelemetryInboundDataRequestToApiRequest(sdkRequest);
        return this._edgeTelemetryMqttClient.createSDKDataSubscription(apiRequest, callback);
    }
    removeTelemetryServiceById(serviceId) {
        if (this._disableStreaming == true) {
            throw Error('Streaming is disabled');
        }
        this._edgeTelemetryMqttClient.removeTelemetryService(serviceId);
    }
}
/**
 * EdgeSDK Configuration class.  These properties can be passed the in constructor of [[EdgeSDK]]
 * Properties are overwritten by environment variables
 */
// tslint:disable-next-line: max-classes-per-file
class EdgeSDKConfig {
    constructor() {
        /**
         * Set whether or not to enable connections that stream data. If disabled, only historical queries will work
         * Optionally set this property to override the default of streaming being enabled
         * This property is overwritten by the environment variable: DISABLE_STREAMING
         */
        this.disableStreaming = false;
        /**
         * Set whether or not to use a secure connection to the EdgeAPI and MQTT Broker
         * Optionally set this property to override the default of false
         * If the application is running inside of the same swarm network as Edge, then it should be false
         * If the application is running externally to the edge system, it should be true.
         * When secure is true, caFile, certFile, and keyFile must be set with valid TLS Certificate file locations
         * This property is overwritten by the environment variable: EDGE_API_SECURE
         */
        this.secure = false;
    }
}
exports.EdgeSDKConfig = EdgeSDKConfig;
/**
 * The entry point class for the Edge SDK.
 * This class contains API calls for Edge Historian, Edge Telemetry, and Edge Service to Service Communication
 */
// tslint:disable-next-line: max-classes-per-file
class EdgeSDK {
    /**
     * Constructs an EdgeSDK Object
     * @param config optionally pass config parameters to customize SDK runtime. These properties are overwritten by environment variables listed in [[EdgeSDKConfig]]
     */
    constructor(config) {
        this._config = config || new EdgeSDKConfig();
        const configProvider = new config_provider_1.ConfigProvider();
        this._endpoints = configProvider.getEndpoints(this._config);
        if (this._config.secure) {
            if (this._config.certFile == undefined || this._config.keyFile == undefined || this._config.caFile == undefined) {
                throw Error('Cannot run in secure mode unless TLS CA & Cert/Key files are defined');
            }
            try {
                this._httpsAgent = new https.Agent({
                    /*reject unauthorized makes sure the passed dns name exists in the server
                              cert's altnames.  This prevents IP addresses from being used for connection.
                              Since we are primarily concerned about the server blocking connections than validating the
                              server is who it says it is, rejectUnauthorized was disabled.  This can be changed
                              if we can guarantee a DNS name will be available for secure connections in the future to Edge
                              */
                    rejectUnauthorized: false,
                    ca: fs.readFileSync(this._config.caFile),
                    cert: fs.readFileSync(this._config.certFile),
                    key: fs.readFileSync(this._config.keyFile),
                    passphrase: undefined,
                });
            }
            catch (err) {
                //logger_service_1.LogService.log(__1.LOG_LEVEL.ERROR, 'unable to create secure agent: ' + err.message);
                return;
            }
        }
        else {
            this._httpsAgent = undefined;
        }
        const logService = logger_service_1.LogService.initialize(this._config.configFilePath);
        this._serviceProvider = new service_provider_1.ServiceProvider(this._endpoints, this._httpsAgent);
        this._routerProvider = new router_provider_1.RouterProvider(logService);
    }
    /**
     * The Edge Historian SDK
     */
    get historian() {
        if (!this._edgeHistorianSdk) {
            this._edgeHistorianSdk = new EdgeHistorianSDK(this._serviceProvider, this._endpoints.edgeApiAddress, this._httpsAgent, this._config.disableStreaming);
        }
        return this._edgeHistorianSdk;
    }
    /**
     * The Edge Telemetry SDK
     */
    get telemetry() {
        if (!this._edgeTelemetrySdk) {
            this._edgeTelemetrySdk = new EdgeTelemetrySDK(this._serviceProvider, this._endpoints.edgeApiAddress, this._httpsAgent, this._config.disableStreaming);
        }
        return this._edgeTelemetrySdk;
    }
    /**
     * The Edge Service to Service SDK
     */
    get serviceComm() {
        if (!this._edgeServiceCommunicationSdk) {
            this._edgeServiceCommunicationSdk = new EdgeServiceCommunicationSDK(this._serviceProvider, this._httpsAgent, this._config.disableStreaming);
        }
        return this._edgeServiceCommunicationSdk;
    }
    /**
     * The Edge IoT Management SDK
     */
    get iotManagement() {
        if (!this._edgeIoTManagementSDK) {
            this._edgeIoTManagementSDK = new edgeIoTManagement_1.EdgeIoTManagement(this._endpoints, this._serviceProvider, this._httpsAgent);
        }
        return this._edgeIoTManagementSDK;
    }
    get commonMiddleware() {
        if (!this._commonMiddleware) {
            throw Error(`Common middleware needs to be initialized first. Use initCommonMiddleware(config: ICommonMiddlewareConfig) method before trying to access common middleware.`);
        }
        return this._commonMiddleware;
    }
    initCommonMiddleware(config) {
        if (this._commonMiddleware) {
            return;
        }
        let rmq, webSocket, dbConnection;
        if (config === null || config === void 0 ? void 0 : config.webSocketPublish) {
            webSocket = this.serviceProvider.webSocket;
        }
        if (config === null || config === void 0 ? void 0 : config.useDbCaching) {
            dbConnection = this.serviceProvider.dbConnection;
        }
        if ((config === null || config === void 0 ? void 0 : config.rabbitMqConfig) != null) {
            rmq = this.serviceProvider.rabbitMq;
        }
        this._commonMiddleware = new common_middleware_service_1.CommonMiddleware(config, rmq, webSocket, dbConnection);
    }
    /**
     * Service provider
     */
    get serviceProvider() {
        return this._serviceProvider;
    }
    /**
     * Router provider - provides configured API routes
     */
    get routerProvider() {
        return this._routerProvider;
    }
}
exports.EdgeSDK = EdgeSDK;
