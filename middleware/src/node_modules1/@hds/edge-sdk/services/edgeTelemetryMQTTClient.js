"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeTelemetryMQTTClient = void 0;
const axios_1 = __importDefault(require("axios"));
const url = __importStar(require("url"));
const uuid_1 = require("uuid");
const edgeTelemetryServiceRequest_1 = require("../models/api/telemetry/edgeTelemetryServiceRequest");
const edgeData_1 = require("../models/edgeData");
const edgeSubscriptionStatus_1 = require("../models/edgeSubscriptionStatus");
const edgeTelemetrySubscriptionInfoManager_1 = require("../models/telemetry/edgeTelemetrySubscriptionInfoManager");
const resultStatusObject_1 = require("./../models/api/resultStatusObject");
const __1 = require("..");
class EdgeTelemetryMQTTClient {
    constructor(serviceProvider, edgeApiAddress, httpsAgent) {
        // public onMessage: EventEmitter = new EventEmitter();
        this.clientId = `sdk_${uuid_1.v4()}`;
        this.edgeTelemetryApiBase = '/api/v1/telemetry';
        this.topicCallbackMap = {};
        this.requestedSubscriptions = {};
        // init MQTT Bridge API urls
        this.edgeApiAddress = edgeApiAddress;
        this.httpsAgent = httpsAgent;
        this.mqttClient = serviceProvider.mqtt;
        this.setupMqttOptions();
    }
    createCustomDataSubscription(telemetryRequest, callback) {
        const subId = uuid_1.v4().toString();
        const requestedSubscription = new edgeTelemetrySubscriptionInfoManager_1.EdgeTelemetrySubscriptionInfoManager(telemetryRequest, callback);
        this.requestedSubscriptions[subId] = requestedSubscription;
        this.startSubscription(requestedSubscription);
        return subId;
    }
    async registerTelemetryService(apiRequest) {
        try {
            // check name duplicates - do not create duplicates
            if (apiRequest.serviceName) {
                const services = await axios_1.default.get('', {
                    timeout: 10000,
                    baseURL: this.getTelemetrySubscriptionBaseUrl(),
                    httpsAgent: this.httpsAgent,
                    proxy: false,
                });
                if (services.data.status !== resultStatusObject_1.ResultStatus.ERROR) {
                    const service = services.data.result.find((s) => s.friendlyName === apiRequest.serviceName);
                    if (service) {
                        const serviceResponse = {
                            message: 'Service with such name already exists.',
                            status: resultStatusObject_1.ResultStatus.WARNING,
                            result: service,
                        };
                        return serviceResponse;
                    }
                }
            }
            const response = await axios_1.default.post('/register', apiRequest, {
                timeout: 10000,
                baseURL: this.getTelemetrySubscriptionBaseUrl(),
                httpsAgent: this.httpsAgent,
                proxy: false,
            });
            return response.data;
        }
        catch (error) {
            return {
                message: error.message,
                status: resultStatusObject_1.ResultStatus.ERROR,
                result: undefined,
            };
        }
    }
    createSDKDataSubscription(telemetryRequest, callback) {
        const subId = uuid_1.v4().toString();
        const requestedSubscription = new edgeTelemetrySubscriptionInfoManager_1.EdgeTelemetrySubscriptionInfoManager(telemetryRequest, callback);
        this.requestedSubscriptions[subId] = requestedSubscription;
        this.startSubscription(requestedSubscription);
        return subId;
    }
    async removeTelemetryService(subscriptionId) {
        const subscription = this.requestedSubscriptions[subscriptionId];
        if (subscription == undefined) {
            return;
        }
        if (subscription.serviceInfo != undefined && subscription.serviceInfo.id != undefined) {
            await axios_1.default.delete('/', {
                params: {
                    id: subscription.serviceInfo.id,
                },
                timeout: 10000,
                baseURL: this.getTelemetrySubscriptionBaseUrl(),
                httpsAgent: this.httpsAgent,
                proxy: false,
            });
        }
        this.stopSubscription(subscription);
        delete this.requestedSubscriptions[subscriptionId];
    }
    getTelemetrySubscriptionBaseUrl() {
        return url.resolve(this.edgeApiAddress, this.edgeTelemetryApiBase);
    }
    async stopSubscription(subscription) {
        if (subscription == undefined) {
            return;
        }
        try {
            subscription.clearTimers();
            if (subscription.serviceInfo != undefined) {
                const mqttPublisherConfig = subscription.serviceInfo.publisherConfig;
                const keepAliveTopic = subscription.serviceInfo.serviceCheckConfig.serviceAliveConfig.topic;
                this.mqttClient.unsubscribe([mqttPublisherConfig.topic, keepAliveTopic]);
                delete this.topicCallbackMap[mqttPublisherConfig.topic];
                delete this.topicCallbackMap[keepAliveTopic];
                subscription.serviceInfo = undefined;
            }
        }
        catch (err) {
            __1.LogService.log(__1.LOG_LEVEL.ERROR, `Telemetry - error while stopping subscription: ${err}`);
        }
    }
    async startSubscription(subscription) {
        if (subscription != undefined &&
            (subscription.status == edgeSubscriptionStatus_1.EdgeSubscriptionStatus.NOT_CONNECTED ||
                subscription.status == edgeSubscriptionStatus_1.EdgeSubscriptionStatus.FAILED)) {
            try {
                if (subscription.serviceInfo != undefined) {
                    this.stopSubscription(subscription);
                }
                subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.CONNECTING;
                const subscriptionResponse = await axios_1.default.post('/register', subscription.apiRequest, {
                    timeout: 10000,
                    baseURL: this.getTelemetrySubscriptionBaseUrl(),
                    httpsAgent: this.httpsAgent,
                    proxy: false,
                });
                if (subscriptionResponse == undefined || subscriptionResponse.data == undefined) {
                    throw Error('no/invalid response from server');
                }
                if (subscriptionResponse.status != 200) {
                    __1.LogService.log(__1.LOG_LEVEL.ERROR, `data subscription invalid response code: ${subscriptionResponse.status}`);
                    // don't return, just note issue
                }
                if (subscriptionResponse.data.status > 0) {
                    throw Error(subscriptionResponse.data.message);
                }
                if (subscriptionResponse.data.result == undefined) {
                    throw Error('no subscription info received from service');
                }
                const serviceInfo = subscriptionResponse.data.result;
                subscription.serviceInfo = serviceInfo;
                subscription.healthcheck.heartbeatTimerId = setInterval(() => this.sendHeartbeatForClient(serviceInfo.serviceCheckConfig.clientHeartbeatConfig.topic, subscription.healthcheck), serviceInfo.serviceCheckConfig.clientHeartbeatTimeout / 4 // send heartbeat at least 3 time before timeout would happen
                );
                const mqttPublisherConfig = serviceInfo.publisherConfig;
                switch (serviceInfo.publisherConfig.type) {
                    case edgeTelemetryServiceRequest_1.EdgeRtDestination.MQTT:
                        this.topicCallbackMap[mqttPublisherConfig.topic] = subscription.callback;
                        this.topicCallbackMap[serviceInfo.serviceCheckConfig.serviceAliveConfig.topic] = () => {
                            subscription.healthcheck.lastAliveTimestamp = Date.now();
                        };
                        break;
                    default:
                        throw Error(`Telemetry - got unhandled publisher type: ${serviceInfo.publisherConfig.type}`);
                }
                this.mqttClient.subscribe([mqttPublisherConfig.topic, serviceInfo.serviceCheckConfig.serviceAliveConfig.topic]);
                // only wire up when everything else has succeeded
                subscription.healthcheck.subscriptionCheckTimerId = setInterval(() => this.checkIfSubscriptionIsAlive(subscription), serviceInfo.serviceCheckConfig.serviceAliveInterval * 4 // allow up to 3 missed keep alive messages in time frame before reconstructing
                );
                subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.CONNECTED;
            }
            catch (err) {
                // wait 5 and try again
                subscription.clearTimers();
                subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.FAILED;
                setTimeout(() => this.startSubscription(subscription), 5000);
                __1.LogService.log(__1.LOG_LEVEL.ERROR, `Telemetry data subscription failed: ${err}`);
            }
        }
    }
    checkIfSubscriptionIsAlive(subscription) {
        if (subscription.serviceInfo == undefined ||
            subscription.healthcheck.lastAliveTimestamp <
                Date.now() - subscription.serviceInfo.serviceCheckConfig.serviceAliveInterval * 4) {
            // 4 is matching multiplier of interval
            subscription.healthcheck.clearTimers();
            subscription.status = edgeSubscriptionStatus_1.EdgeSubscriptionStatus.FAILED;
            setImmediate(() => this.startSubscription(subscription));
        }
    }
    sendHeartbeatForClient(clientHeartbeatTopic, healtCheckInfo) {
        if (this.mqttClient.isConnected) {
            this.mqttClient.publish(clientHeartbeatTopic, JSON.stringify({ count: healtCheckInfo.counter++ }));
        }
    }
    setupMqttOptions() {
        this.mqttClient.message$.subscribe(({ topic, message }) => {
            const callback = this.topicCallbackMap[topic];
            if (callback != undefined && message != undefined) {
                let data = undefined;
                try {
                    data = Object.assign(new edgeData_1.EdgeData(), JSON.parse(message.toString()));
                }
                catch (err) {
                    __1.LogService.log(__1.LOG_LEVEL.ERROR, 'Telemetry received non IEdgeData message...');
                    return;
                }
                callback(data);
            }
        });
    }
}
exports.EdgeTelemetryMQTTClient = EdgeTelemetryMQTTClient;
